import path from 'path';
import fs from 'fs-extra';
import { RequirementSpec, GeneratedFile, FrameworkConfig } from '../types';
import { Logger } from '../utils/logger';

export class DatabaseGenerator {
  private logger: Logger;
  private config: FrameworkConfig;

  constructor(config: FrameworkConfig, logger: Logger) {
    this.config = config;
    this.logger = logger;
  }

  async generate(spec: RequirementSpec, outputDir: string): Promise<GeneratedFile[]> {
    this.logger.info('Generating database schema and migrations...');
    
    await fs.ensureDir(outputDir);
    const files: GeneratedFile[] = [];

    if (spec.techStack.database.type === 'postgresql') {
      files.push(...await this.generatePostgreSQLSchema(spec, outputDir));
    } else if (spec.techStack.database.type === 'mongodb') {
      files.push(...await this.generateMongoDBSchema(spec, outputDir));
    } else if (spec.techStack.database.type === 'sqlite') {
      files.push(...await this.generateSQLiteSchema(spec, outputDir));
    }

    return files;
  }

  private async generatePostgreSQLSchema(spec: RequirementSpec, outputDir: string): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const migrationsDir = path.join(outputDir, 'migrations');
    await fs.ensureDir(migrationsDir);

    let schema = `-- Database: ${spec.techStack.database.database}
-- Generated by Autonomous Web Framework

`;

    if (spec.authentication) {
      schema += `
-- Users table
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

`;
    }

    // Generate tables based on features
    for (const feature of spec.features) {
      if (feature.name.toLowerCase().includes('task') || feature.name.toLowerCase().includes('todo')) {
        schema += `
-- Tasks table
CREATE TABLE IF NOT EXISTS tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    priority VARCHAR(20) DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),
    due_date TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_completed ON tasks(completed);
CREATE INDEX idx_tasks_priority ON tasks(priority);

`;
      }

      if (feature.name.toLowerCase().includes('project')) {
        schema += `
-- Projects table
CREATE TABLE IF NOT EXISTS projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'archived')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_projects_status ON projects(status);

`;
      }
    }

    if (spec.fileUploads) {
      schema += `
-- Files table
CREATE TABLE IF NOT EXISTS files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    filename VARCHAR(255) NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    size INTEGER NOT NULL,
    path VARCHAR(500) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_files_user_id ON files(user_id);
CREATE INDEX idx_files_created_at ON files(created_at);

`;
    }

    // Create initial migration
    const migrationContent = `-- Migration: Initial Schema
-- Created: ${new Date().toISOString()}

${schema}

-- Insert default data
${spec.authentication ? `
INSERT INTO users (name, email, password) VALUES 
('Admin User', 'admin@example.com', '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj88Q/Pq9yFy') -- password: admin123
ON CONFLICT (email) DO NOTHING;
` : ''}
`;

    const migrationPath = path.join(migrationsDir, '001_initial_schema.sql');
    await fs.writeFile(migrationPath, migrationContent);
    files.push({
      path: 'database/migrations/001_initial_schema.sql',
      content: migrationContent,
      type: 'config',
      lastModified: new Date(),
      size: migrationContent.length
    });

    // Create schema documentation
    const schemaDoc = this.generateSchemaDocumentation(spec);
    const schemaDocPath = path.join(outputDir, 'schema.md');
    await fs.writeFile(schemaDocPath, schemaDoc);
    files.push({
      path: 'database/schema.md',
      content: schemaDoc,
      type: 'markdown',
      lastModified: new Date(),
      size: schemaDoc.length
    });

    return files;
  }

  private async generateMongoDBSchema(spec: RequirementSpec, outputDir: string): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const schemasDir = path.join(outputDir, 'schemas');
    await fs.ensureDir(schemasDir);

    if (spec.authentication) {
      const userSchema = `import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    minlength: 2,
    maxlength: 255
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/, 'Please enter a valid email']
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  },
  emailVerified: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
userSchema.index({ email: 1 }, { unique: true });
userSchema.index({ createdAt: 1 });

// Pre-save middleware to hash password
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// Instance method to compare password
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

// Remove password from JSON output
userSchema.methods.toJSON = function() {
  const user = this.toObject();
  delete user.password;
  return user;
};

export const User = mongoose.model('User', userSchema);
`;

      const userSchemaPath = path.join(schemasDir, 'User.ts');
      await fs.writeFile(userSchemaPath, userSchema);
      files.push({
        path: 'database/schemas/User.ts',
        content: userSchema,
        type: 'typescript',
        lastModified: new Date(),
        size: userSchema.length
      });
    }

    // Generate schemas for other entities based on features
    for (const feature of spec.features) {
      if (feature.name.toLowerCase().includes('task')) {
        const taskSchema = this.generateMongoTaskSchema(spec.authentication);
        const taskSchemaPath = path.join(schemasDir, 'Task.ts');
        await fs.writeFile(taskSchemaPath, taskSchema);
        files.push({
          path: 'database/schemas/Task.ts',
          content: taskSchema,
          type: 'typescript',
          lastModified: new Date(),
          size: taskSchema.length
        });
      }
    }

    return files;
  }

  private generateMongoTaskSchema(hasAuth: boolean): string {
    return `import mongoose from 'mongoose';

const taskSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 255
  },
  description: {
    type: String,
    trim: true
  },
  completed: {
    type: Boolean,
    default: false
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high'],
    default: 'medium'
  },
  dueDate: {
    type: Date
  }${hasAuth ? `,
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }` : ''}
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
taskSchema.index({ completed: 1 });
taskSchema.index({ priority: 1 });
taskSchema.index({ dueDate: 1 });
${hasAuth ? 'taskSchema.index({ user: 1 });' : ''}

export const Task = mongoose.model('Task', taskSchema);
`;
  }

  private async generateSQLiteSchema(spec: RequirementSpec, outputDir: string): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    let schema = `-- SQLite Database Schema
-- Database: ${spec.techStack.database.database}
-- Generated by Autonomous Web Framework

PRAGMA foreign_keys = ON;

`;

    if (spec.authentication) {
      schema += `
-- Users table
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    email_verified INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

`;
    }

    // Add other tables based on features
    for (const feature of spec.features) {
      if (feature.name.toLowerCase().includes('task')) {
        schema += `
-- Tasks table
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    description TEXT,
    completed INTEGER DEFAULT 0,
    priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),
    due_date DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP${spec.authentication ? ',\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE' : ''}
);

${spec.authentication ? 'CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);' : ''}
CREATE INDEX IF NOT EXISTS idx_tasks_completed ON tasks(completed);

`;
      }
    }

    const schemaPath = path.join(outputDir, 'schema.sql');
    await fs.writeFile(schemaPath, schema);
    files.push({
      path: 'database/schema.sql',
      content: schema,
      type: 'config',
      lastModified: new Date(),
      size: schema.length
    });

    return files;
  }

  private generateSchemaDocumentation(spec: RequirementSpec): string {
    let doc = `# Database Schema Documentation

**Database**: ${spec.techStack.database.database}  
**Type**: ${spec.techStack.database.type}  
**Generated**: ${new Date().toISOString()}

## Overview

This document describes the database schema for ${spec.title}.

## Tables

`;

    if (spec.authentication) {
      doc += `
### Users Table

Stores user account information.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID/INTEGER | Primary key |
| name | VARCHAR(255) | User's full name |
| email | VARCHAR(255) | User's email address (unique) |
| password | VARCHAR(255) | Hashed password |
| email_verified | BOOLEAN | Email verification status |
| created_at | TIMESTAMP | Record creation time |
| updated_at | TIMESTAMP | Last update time |

**Indexes:**
- idx_users_email (email)
- idx_users_created_at (created_at)

`;
    }

    for (const feature of spec.features) {
      if (feature.name.toLowerCase().includes('task')) {
        doc += `
### Tasks Table

Stores task/todo items.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID/INTEGER | Primary key |
| title | VARCHAR(255) | Task title |
| description | TEXT | Task description (optional) |
| completed | BOOLEAN | Completion status |
| priority | VARCHAR(20) | Priority level (low/medium/high) |
| due_date | TIMESTAMP | Due date (optional) |
| created_at | TIMESTAMP | Record creation time |
| updated_at | TIMESTAMP | Last update time |
${spec.authentication ? '| user_id | UUID/INTEGER | Foreign key to users table |' : ''}

**Indexes:**
- idx_tasks_completed (completed)
- idx_tasks_priority (priority)
${spec.authentication ? '- idx_tasks_user_id (user_id)' : ''}

`;
      }
    }

    if (spec.fileUploads) {
      doc += `
### Files Table

Stores uploaded file metadata.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID/INTEGER | Primary key |
| filename | VARCHAR(255) | Generated filename |
| original_name | VARCHAR(255) | Original filename |
| mime_type | VARCHAR(100) | File MIME type |
| size | INTEGER | File size in bytes |
| path | VARCHAR(500) | File storage path |
| created_at | TIMESTAMP | Upload time |
${spec.authentication ? '| user_id | UUID/INTEGER | Foreign key to users table |' : ''}

`;
    }

    doc += `
## Relationships

`;

    if (spec.authentication) {
      doc += `- Users have a one-to-many relationship with tasks\n`;
      if (spec.fileUploads) {
        doc += `- Users have a one-to-many relationship with files\n`;
      }
    }

    doc += `
## Constraints

- All tables use UUIDs for primary keys (PostgreSQL) or auto-incrementing integers (SQLite)
- Email addresses must be unique in the users table
- Foreign key constraints ensure referential integrity
- Check constraints ensure data validity (e.g., priority values)

## Indexes

Indexes are created to optimize common query patterns:
- User lookups by email
- Task filtering by completion status and priority
- File access by user
`;

    return doc;
  }
}